<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>编译器中的Parser，语法分析器，以及抽象语法树AST</title>
    <link href="/2023/01/04/llvm-parser/"/>
    <url>/2023/01/04/llvm-parser/</url>
    
    <content type="html"><![CDATA[<p>之前我们学习了词法分析器，接下来，依据词法分析器的输出，我们将进一步对代码进行处理。这里我们用到的是语法分析器，Parser。Parser的输出是一个抽象语法树（Abstract Syntax Tree，AST）。</p><p>Parser的构建采用的是两种方法的结合，Recursive Descent Parsing（递归下降解析）和Operator-Precedence Parsing（运算符优先解析）。后者仅用于二元表达式（Binary Expression），而其他情况使用前者。</p><p>递归下降解析是指一种自上而下的解析器，由一组相互递归的程序（或等价的非递归程序）构建而成，其中每个程序都实现了文法中的一个非终结符。因此，这些程序的结构密切反映了它所识别的文法结构。–wiki百科</p><p>运算符优先解析是一个自下而上的解析过程，它解释运算符先验的语法。很多计算器使用的是运算符有限解析。–wiki百科</p><p>由于parser的输出是AST，我们首先介绍一下AST。</p><h1 id="抽象语法树，AST"><a href="#抽象语法树，AST" class="headerlink" title="抽象语法树，AST"></a>抽象语法树，AST</h1><p>一段程序的AST捕捉了这段程序的行为，从而可以为后续的编译过程（例如代码生成，code generation）提供便利。AST应该尽量紧密的模拟语言，对于语言中的每一个结构，我们都在AST中有对应的对象。在K语言中，我们有表达式expression，原型prototype和函数对象function object。首先我们从表达式开始。</p>]]></content>
    
    
    <categories>
      
      <category>Compiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
      <tag>LLVM</tag>
      
      <tag>Parser</tag>
      
      <tag>AST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译器中的Lexer，词法分析器</title>
    <link href="/2023/01/03/llvm-lexer/"/>
    <url>/2023/01/03/llvm-lexer/</url>
    
    <content type="html"><![CDATA[<p>最近在对LLVM IR起了兴趣，应为它可以将它支持的所有编程语言都转换成同一个IR语言。LLVM IR生成步骤有三步，首先是词法解析，然后是语法分析生成AST，然后AST可以通过代码生成，得到IR。我是跟着LLVM的<a href="https://llvm.org/docs/tutorial/index.html">官方教程</a>学习的，这个教程通过一个很简单的，虚构的编程语言Kaleidoscope来教你一步步实现自己的编程语言以及对应的编译器。</p><h1 id="Kaleidoscope语言"><a href="#Kaleidoscope语言" class="headerlink" title="Kaleidoscope语言"></a>Kaleidoscope语言</h1><p>Kaleidoscope是一个程序性语言，简单起见，我们规定Kaleidoscope中的数字类型仅有双精度浮点数类型，因此也无需进行类型声明。这样Kaleidoscope就有了很简单的语法，下面的例子是Kaleidoscope写成的斐波那契数列函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># Compute the x<span class="hljs-number">&#x27;</span>th fibonacci number.<br><span class="hljs-function">def <span class="hljs-title">fib</span><span class="hljs-params">(x)</span></span><br><span class="hljs-function">  <span class="hljs-keyword">if</span> x &lt; 3</span><br><span class="hljs-function">    <span class="hljs-keyword">return</span> 1</span><br><span class="hljs-function">  <span class="hljs-keyword">else</span></span><br><span class="hljs-function">    <span class="hljs-keyword">return</span> <span class="hljs-title">fib</span><span class="hljs-params">(x<span class="hljs-number">-1</span>)</span>+<span class="hljs-title">fib</span><span class="hljs-params">(x<span class="hljs-number">-2</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"># This expression will compute the 40th number.</span><br><span class="hljs-function"><span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-number">40</span>)</span></span><br></code></pre></td></tr></table></figure><p>此外，我们还允许Kaleidoscope调用标准库中的函数，之后的LLVM JIT会使实现这个功能变得非常简单。Kaleidoscope通过关键字<code>extern</code>在使用之前定义一个函数（在手动定义递归函数中也有用），下面是一个例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># 声明三个标准库中的函数<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">sin</span><span class="hljs-params">(arg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">cos</span><span class="hljs-params">(arg)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">atan2</span><span class="hljs-params">(arg1 arg2)</span></span>;<br><br><span class="hljs-built_in">atan2</span>(<span class="hljs-built_in">sin</span>(<span class="hljs-number">.4</span>), <span class="hljs-built_in">cos</span>(<span class="hljs-number">42</span>))<br></code></pre></td></tr></table></figure><p>这里我们可以基本上理解了Kaleidoscope语言的基本语法，下面就开始实现这个语言的第一步，词法分析器。</p><h1 id="词法分析器，Lexer"><a href="#词法分析器，Lexer" class="headerlink" title="词法分析器，Lexer"></a>词法分析器，Lexer</h1><p>首先介绍一下编译器编译代码的第一步，词法分析器，Lexer。</p><p>词法分析器处理编程语言的代码文本，并理解这些文本表达了什么。词法分析器lexer（也称为scanner），将代码文本识别成一系列token，每个token被识别为一个编程语言中的定义，例如关键字，标识符，literal等。每个token包含一个token的代码以及可能的一些信息（例如，如果该token是一个数字，那么包含的信息还有这个数字的值）。</p><p>下面，我们将所有可能出现的token类型进行枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 词法分析器如果遇到识别不了的字符，那么返回该字符的ASCII码，即[0-255]</span><br><span class="hljs-comment">// 如果是可以识别的类型，那么返回下面定义的负数。</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Token</span><br>&#123;<br>    tok_eof = <span class="hljs-number">-1</span>,   <span class="hljs-comment">// end of file</span><br><br>    <span class="hljs-comment">// 关键字</span><br>    tok_def = <span class="hljs-number">-2</span>,<br>    tok_if = <span class="hljs-number">-3</span>,<br>    tok_else = <span class="hljs-number">-4</span>,<br>    tok_return = <span class="hljs-number">-5</span>,<br><br>    <span class="hljs-comment">// 主要类型</span><br>    tok_identifier = <span class="hljs-number">-6</span>,<br>    tok_number = <span class="hljs-number">-7</span>,<br><br>    <span class="hljs-comment">// 注释</span><br>    tok_comment = <span class="hljs-number">-8</span><br>&#125;;<br><br><span class="hljs-type">static</span> std::string identifier_str;  <span class="hljs-comment">// 如果识别为identifier，那么将它的文本储存到这里</span><br><span class="hljs-type">static</span> <span class="hljs-type">double</span> num_val;              <span class="hljs-comment">// 如果识别为数字，那么将其值储存到这里</span><br><span class="hljs-type">static</span> std::string comment_line;    <span class="hljs-comment">// 如果识别为注释，那么将注释字符串储存到这里</span><br></code></pre></td></tr></table></figure><p>Lexer返回的每个token只有两种情况，一是上面枚举类型中存在的负数，二是不能识别的字符，例如”+”，这时lexer返回的是该字符的ASCII码值，范围为0-255。</p><p>如果识别到标识符identifier，那么我们将该标识符的名称赋值给<code>identifier_str</code>。如果识别到数字，那么我们将该数字表示的值赋值给<code>num_val</code>。如果识别到注释行，那么我们将注释的字符串赋值给<code>comment_line</code>。注意这里我们简单起见，使用的是全局变量来储存这些值，但这并不是一个好的选择，在真实的编译器实现中，显然不会用这个函数。</p><p>Lexer的实现是通过一个函数<code>get_tok</code>实现的，它持续读取代码文本的下一个字符，直到识别到下一个token并返回。下面我们通过一个简单的实现对这个函数进行解释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::ifstream fin;  <span class="hljs-comment">// 全局变量，C++读文件的流，在使用时应先打开一个文件，最后关闭</span><br><br><span class="hljs-comment">// 返回的是int值，如果是负数，则是之前定一个Token枚举类型中的值</span><br><span class="hljs-comment">// 如果是正数，则是未识别的字符的ASCII码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_tok</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 读取到的字符</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> last_char = <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-comment">// 通过fin.get()函数从标准输入中一次读取一个字符</span><br>    <span class="hljs-comment">// 首先是跳过所有的空白字符</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isspace</span>(last_char))<br>        last_char = fin.<span class="hljs-built_in">get</span>();<br><br>    <span class="hljs-comment">// 然后是识别标识符，并判断是不是关键字</span><br>    <span class="hljs-comment">// 标识符identifier的正则: [a-zA-Z][a-zA-Z0-9_]*</span><br>    <span class="hljs-comment">// 标识符仅由字母，数字和下划线组成，并由字母开头</span><br>    <span class="hljs-comment">// isalpha判断当前字符是否是字母</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(last_char))<br>    &#123;<br>        <span class="hljs-comment">// 全局变量identifier_str储存标识符的名称</span><br>        identifier_str = last_char;<br>        last_char = fin.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-comment">// isalnum判断是否是字母或数字</span><br>        <span class="hljs-comment">// 符合标识符命名的情况下，持续读取</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isalnum</span>(last_char) || last_char == <span class="hljs-string">&#x27;_&#x27;</span>)<br>        &#123;<br>            <span class="hljs-comment">// 将下一个字符拼接到标识符名称后</span><br>            identifier_str += last_char;<br>            <span class="hljs-comment">// 读取下一个字符</span><br>            last_char = fin.<span class="hljs-built_in">get</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 判断识别到的标识符是否是关键字</span><br>        <span class="hljs-comment">// 如果是关键字，则返回关键字对应的token id</span><br>        <span class="hljs-keyword">if</span> (identifier_str == <span class="hljs-string">&quot;def&quot;</span>)<br>            <span class="hljs-keyword">return</span> tok_def;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (identifier_str == <span class="hljs-string">&quot;if&quot;</span>)<br>            <span class="hljs-keyword">return</span> tok_if;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (identifier_str == <span class="hljs-string">&quot;else&quot;</span>)<br>            <span class="hljs-keyword">return</span> tok_else;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (identifier_str == <span class="hljs-string">&quot;return&quot;</span>)<br>            <span class="hljs-keyword">return</span> tok_return;<br>        <span class="hljs-comment">// 如果不是关键字，则表明是自定义标识符，返回identifier的id</span><br>        <span class="hljs-comment">// 这时自定义的标识符的名字则储存在全局变量identifier_str中</span><br>        <span class="hljs-keyword">return</span> tok_identifier;<br>    &#125;<br><br>    <span class="hljs-comment">// 然后是数字，简单起见，我们将这里的数字的正则定义为[0-9.]+</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(last_char) || last_char == <span class="hljs-string">&#x27;.&#x27;</span>)<br>    &#123;<br>        <span class="hljs-comment">// num_str用来储存数字值的字符串</span><br>        std::string num_str;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            num_str += last_char;<br>            last_char = fin.<span class="hljs-built_in">get</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(last_char) || last_char == <span class="hljs-string">&#x27;.&#x27;</span>);<br>        <br>        <span class="hljs-comment">// 接下来需要将用字符表示的值转换为双精度浮点值</span><br>        <span class="hljs-comment">// strtod是C标准库中的函数，将str转换为双精度浮点值</span><br>        num_val = <span class="hljs-built_in">strtod</span>(num_str.<span class="hljs-built_in">c_str</span>(), <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-comment">// 返回数字的id，同时数字的值被储存在全局变量num_val中</span><br>        <span class="hljs-keyword">return</span> tok_number;<br><br>        <span class="hljs-comment">// 由于我们简单起见将数字定义为[0-9.]+，这会导致一个问题</span><br>        <span class="hljs-comment">// 就是这也会识别例如1.23.4.5这样的序列，这在strtod函数后只会保留前面有效的部分，即1.23，这是不对的</span><br>        <span class="hljs-comment">// 因此在真正实现时还要考虑这一点，例如限制小数点只能识别到一次等</span><br>    &#125;<br><br>    <span class="hljs-comment">// 接下来是注释，之前我们也了解到Kaleidoscope语言的注释仅有行注释，而没有块注释，行注释由#号开始</span><br>    <span class="hljs-comment">// 因此当识别到#时，表示接下来的一行都是注释</span><br>    <span class="hljs-keyword">if</span> (last_char == <span class="hljs-string">&#x27;#&#x27;</span>)<br>    &#123;<br>        comment_line = last_char;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            last_char = fin.<span class="hljs-built_in">get</span>();<br>            comment_line += last_char;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (last_char != EOF &amp;&amp; last_char != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; last_char != <span class="hljs-string">&#x27;\r&#x27;</span>);<br>        <span class="hljs-comment">// 只要不识别到文件结束，或者换行，则都是注释的内容</span><br>        <span class="hljs-comment">// 最后将注释的id返回，此时注释的内容储存在全局变量comment_line中</span><br>        <span class="hljs-keyword">return</span> tok_comment;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否是到了文件结束</span><br>    <span class="hljs-keyword">if</span> (last_char == EOF)<br>        <span class="hljs-keyword">return</span> tok_eof;<br><br>    <span class="hljs-comment">// 如果当前字符串不是Token枚举类中列出的，则将其ASCII码返回</span><br>    <span class="hljs-type">int</span> this_char = last_char;<br>    last_char = fin.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">return</span> this_char;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里我们就完成了一个简单的lexer的核心，get_tok函数。我们在外面再写一个驱动，用于循环调用get_tok函数，并接受它的输出，对它识别到的每一个token进行我们需要的处理，下面我们写一个简单的函数，将get_tok函数读取到的token输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fin.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;fibonacci.ks&quot;</span>, std::ios::in);<br>    <span class="hljs-keyword">if</span> (!fin.<span class="hljs-built_in">is_open</span>())<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Cannot open file &#x27;fibonacci.ks&#x27;.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">get_tok</span>();<br>        <span class="hljs-keyword">if</span> (res == tok_def || res == tok_if || res == tok_else || res == tok_return)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Keywords: &quot;</span> &lt;&lt; identifier_str &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res == tok_identifier)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Identifier: &quot;</span> &lt;&lt; identifier_str &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res == tok_number)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Number: &quot;</span> &lt;&lt; num_val &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res == tok_comment)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Comment line: &quot;</span> &lt;&lt; comment_line &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res == tok_eof)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;End of file&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Unknown char: &quot;</span> &lt;&lt; <span class="hljs-built_in">char</span>(res) &lt;&lt; <span class="hljs-string">&quot;, ASCII code: &quot;</span> &lt;&lt; res &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (res == EOF)<br>        &#123;<br>            fin.<span class="hljs-built_in">close</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时我们将上面的斐波那契数列的Kaleidoscope代码储存在<code>fibonacci.ks</code>文件中，就可以得到下面的输出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs sh">Comment line: <span class="hljs-comment"># Compute the x&#x27;th fibonacci number.</span><br><br>Keywords: def<br>Identifier: fib<br>Unknown char: (, ASCII code: 40<br>Identifier: x<br>Unknown char: ), ASCII code: 41<br>Keywords: <span class="hljs-keyword">if</span><br>Identifier: x<br>Unknown char: &lt;, ASCII code: 60<br>Number: 3<br>Keywords: <span class="hljs-built_in">return</span><br>Number: 1<br>Keywords: <span class="hljs-keyword">else</span><br>Keywords: <span class="hljs-built_in">return</span><br>Identifier: fib<br>Unknown char: (, ASCII code: 40<br>Identifier: x<br>Unknown char: -, ASCII code: 45<br>Number: 1<br>Unknown char: ), ASCII code: 41<br>Unknown char: +, ASCII code: 43<br>Identifier: fib<br>Unknown char: (, ASCII code: 40<br>Identifier: x<br>Unknown char: -, ASCII code: 45<br>Number: 2<br>Unknown char: ), ASCII code: 41<br>Comment line: <span class="hljs-comment"># This expression will compute the 40th number.</span><br><br>Identifier: fib<br>Unknown char: (, ASCII code: 40<br>Number: 40<br>Unknown char: ), ASCII code: 41<br>End of file<br></code></pre></td></tr></table></figure><p>到这里我们就实现了一个简单的词法分析器，接下来，就到了parser和AST的实现了。</p>]]></content>
    
    
    <categories>
      
      <category>Compiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
      <tag>LLVM</tag>
      
      <tag>Lexer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码预训练模型总结</title>
    <link href="/2023/01/03/code-ptms/"/>
    <url>/2023/01/03/code-ptms/</url>
    
    <content type="html"><![CDATA[<p>这篇文章简单总结一些针对源代码的预训练模型，主要关注的是基于Transformer的大型预训练模型。此外，我们还主要关注针对各种下游任务的通用代码预训练模型，如果只是利用了预训练来提升模型在某一个下游任务上的表现，并没有在多个下游任务上进行验证，我们不认为这是一个通用的代码预训练模型，这里不会进行介绍。</p><h1 id="CuBERT"><a href="#CuBERT" class="headerlink" title="CuBERT"></a>CuBERT</h1><h1 id="C-BERT"><a href="#C-BERT" class="headerlink" title="C-BERT"></a>C-BERT</h1><h1 id="CodeBERT"><a href="#CodeBERT" class="headerlink" title="CodeBERT"></a>CodeBERT</h1><h1 id="GraphCodeBERT"><a href="#GraphCodeBERT" class="headerlink" title="GraphCodeBERT"></a>GraphCodeBERT</h1><h1 id="PLBART"><a href="#PLBART" class="headerlink" title="PLBART"></a>PLBART</h1><h1 id="CodeT5"><a href="#CodeT5" class="headerlink" title="CodeT5"></a>CodeT5</h1><h1 id="CoTexT"><a href="#CoTexT" class="headerlink" title="CoTexT"></a>CoTexT</h1><h1 id="TreeBERT"><a href="#TreeBERT" class="headerlink" title="TreeBERT"></a>TreeBERT</h1><h1 id="SPT-Code"><a href="#SPT-Code" class="headerlink" title="SPT-Code"></a>SPT-Code</h1><h1 id="SynCoBERT"><a href="#SynCoBERT" class="headerlink" title="SynCoBERT"></a>SynCoBERT</h1><h1 id="UniXcoder"><a href="#UniXcoder" class="headerlink" title="UniXcoder"></a>UniXcoder</h1>]]></content>
    
    
    <categories>
      
      <category>Paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Paper</tag>
      
      <tag>Survey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的std::move</title>
    <link href="/2023/01/03/cpp-std-move/"/>
    <url>/2023/01/03/cpp-std-move/</url>
    
    <content type="html"><![CDATA[<p>在右值引用的文章中，我们知道，借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p><p>注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11标准中已经给出了解决方案，即调用move()函数。</p><p>move虽然本意为”移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。</p><p>举一个例子，C++标准库中向量vector的push_back操作，会对参数的对象进行复制，连数据也会复制。这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了，通过std::move，就可以避免不必要的拷贝操作。</p><p>std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率，改善性能。</p><p>move的本质就是帮助编译器选择重载函数, 告诉编译器”请尽量把此参数当做右值来处理”，并且告诉编译器，之后将不再使用这个对象。因为使用拷贝构造方法的话，是对原来的对象没有任何影响的，但是如果使用的是移动构造方法，由于只是发生了所有权转移，并没有复制该对象，因此使用移动构造方法后，原来的对象将无法使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::vector&lt;std::string&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(std);               <span class="hljs-comment">// 调用复制构造方法，对str无影响</span><br>std::cout &lt;&lt; str;               <span class="hljs-comment">// &quot;Hello&quot;</span><br>v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(str));    <span class="hljs-comment">// 调用移动构造方法，之后str无法继续使用</span><br>std::cout &lt;&lt; str;               <span class="hljs-comment">// &quot;&quot;，str此时为空</span><br>v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(str));    <span class="hljs-comment">// 可以执行，但是新元素是空</span><br>std::cout &lt;&lt; v.<span class="hljs-built_in">size</span>();          <span class="hljs-comment">// 3，&quot;Hello&quot;-&gt;&quot;Hello&quot;-&gt;&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的左值和右值</title>
    <link href="/2023/01/03/cpp-lr-value/"/>
    <url>/2023/01/03/cpp-lr-value/</url>
    
    <content type="html"><![CDATA[<h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><p>C++中有左值（lvalue）和右值（rvalue），简单来说，左值是一个对象的引用，而右值是一个值。</p><p>左值是一个表达式，它产生一个对象的引用，比如变量名，一个数组下标的引用，一个解除引用后的指针（dereferenced pointer），或一个返回方法引用的方法调用。左值在内存中必定存在一个确定的位置，从而我们可以得到它的地址。</p><p>右值是不是左值的表达式，例如literals，大部分操作符的结果，或者返回非引用的方法调用。右值并不需要在内存中右确切的地址。</p><p>在C++中，一个值要么是右值，要么是左值，左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象。所有的具名变量或者对象都是左值，而右值不具名。</p><p>只有左值可以出现在赋值符号（&#x3D;）的左边，而左值和右值均可以出现在赋值符号的右边。</p><p>当一个对象被用作左值时，使用的是它的引用（地址），被用作右值时，使用的是它的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;      <span class="hljs-comment">// x是左值，1是右值，这里将1赋值给x，使用的是1的值，储存在x的地址中。</span><br><span class="hljs-type">int</span> y = x;      <span class="hljs-comment">// y是左值，x是右值，这里x成为了左值，实际使用的是它的值（1），储存在y的地址中。</span><br><span class="hljs-number">1</span> = x;          <span class="hljs-comment">// 错误，1是literal，只能是右值。</span><br>(x + <span class="hljs-number">1</span>) = <span class="hljs-number">2</span>;    <span class="hljs-comment">// 错误，x+1可以看做是一个内嵌方法，它返回的是一个值（2），同样是literal。</span><br></code></pre></td></tr></table></figure><p>但并不是所有的方法都只能当作右值，一个方法可以通过它返回的对象类型进行判断，当这个方法返回一个非引用的对象时，它是右值，返回引用时，是左值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> GLOBAL_VAR = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> GLOBAL_VAR;  <span class="hljs-comment">// 返回的是GLOBAL_VAR的引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">foo</span>() = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 正确，foo返回的是引用，可以作为左值。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，我们可以使用左值和右值来解释一些现象。例如++操作，++i是自增操作，这个表达式是将i的值加一，然后返回i，这时返回的是加一之后i的地址，所以++i是一个左值表达式。相反，后自增i++返回的是i+1的结果值，是一个临时变量，而i的值不会发生变化，所以i++是一个右值表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j;<br>j = ++i;        <span class="hljs-comment">// i=1，j=1</span><br>j = i++;        <span class="hljs-comment">// i=1，j=2</span><br>j = (++i)++;    <span class="hljs-comment">// i=2，j=3，++i返回的是i的地址，是左值表达式，可以进行后自增操作</span><br>j = (i++)++;    <span class="hljs-comment">// 错误，i++返回的是一个值，是右值表达式，右值表达式不能进行后自增操作</span><br></code></pre></td></tr></table></figure><p>值得注意的是，如果一个变量在声明为常量（const），它虽然在内存中有确切的地址，但是它不可修改，不可出现在赋值符号的左边。此外，有些地方说左值可以被修改，而右值不能，这是不严谨的。右值引用的出现使得右值也可以被修改。</p><h1 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h1><h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>有些人定义左值为，一个在内存中有地址的表达式，我们可以通过”&amp;”获取它的地址。因此，左值引用就是对左值的引用，我们使用&amp;符号获取它的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>i = <span class="hljs-number">2</span>;              <span class="hljs-comment">// 正确，i是左值</span><br><span class="hljs-type">int</span>* p = &amp;i;        <span class="hljs-comment">// 正确，&amp;i取i的地址，用指针p指向该地址</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;         <span class="hljs-comment">// foo()的返回值是一个引用，因此它是左值</span><br><span class="hljs-built_in">foo</span>() = <span class="hljs-number">1</span>;          <span class="hljs-comment">// 正确，foo()是一个左值</span><br><span class="hljs-type">int</span>* p1 = &amp;<span class="hljs-built_in">foo</span>();   <span class="hljs-comment">// 正确，&amp;取foo()的地址，用指针p1指向该地址</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo1</span><span class="hljs-params">()</span></span>;         <span class="hljs-comment">// foo1的返回值为literal，是一个右值</span><br><span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>j = <span class="hljs-built_in">foo1</span>();         <span class="hljs-comment">// 正确，foo1是右值</span><br><span class="hljs-type">int</span>* p2 = &amp;<span class="hljs-built_in">foo1</span>();  <span class="hljs-comment">// 错误，&amp;并不能取右值的地址</span><br></code></pre></td></tr></table></figure><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>而右值引用则是两个&amp;，即&amp;&amp;。右值引用是C++11标准中出现的新特性，它和相关的移动语义概念的出现可以在某种程度上避免一些不必要的复制，从而提高效率。</p><p>右值引用，用以引用一个右值，可以延长右值的生命期，因为我们在上面说到，右值在表达式结束后将不存在，而使用右值引用，就可以使其继续存在，从而充分使用临时变量，或者即将不使用的变量即右值的资源，减少不必要的拷贝，提高效率。</p><p>关于右值引用的介绍，我觉得<a href="https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/">这篇博客</a>解释的很好，我用它的例子解释一下。</p><p>首先，我们想要实现一个整数的vector类，那么我们可以这样定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntVec</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">IntVec</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">        : m_size(num), m_data(new int[m_size])</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;constructor&quot;</span>);     <span class="hljs-comment">// 构造函数，参数是int，构建一个长度为num的向量</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">Intvec</span>()<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;destructor&quot;</span>);      <span class="hljs-comment">// 析构函数</span><br>        <span class="hljs-keyword">if</span> (m_data)<br>        &#123;<br>            <span class="hljs-keyword">delete</span>[] m_data;<br>            m_data = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">IntVec</span>(<span class="hljs-type">const</span> IntVec&amp; other)<br>        : <span class="hljs-built_in">m_size</span>(other.m_size), <span class="hljs-built_in">m_data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[m_size])<br>    &#123;<br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy constructor&quot;</span>);<br>        <span class="hljs-comment">// 拷贝构造函数，参数是另一个IntVec实例，实现深拷贝，将参数中的向量的每个元素复制到该向量中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; m_size; ++i)<br>            m_data[i] = other.m_data[i];<br>    &#125;<br><br>    IntVec&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Intvec&amp; other)<br>    &#123;<br>        <span class="hljs-comment">// 重载=操作符，也是深拷贝，先用上面的拷贝构造函数拷贝一个tmp，然后用swap拷贝数据</span><br>        <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;copy assignment operator&quot;</span>);<br>        <span class="hljs-function">IntVec <span class="hljs-title">tmp</span><span class="hljs-params">(other)</span></span>;<br>        std::<span class="hljs-built_in">swap</span>(m_size, tmp.m_size);<br>        std::<span class="hljs-built_in">swap</span>(m_data, tmp.m_data);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; <span class="hljs-string">&quot;] &quot;</span> &lt;&lt; msg &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-type">size_t</span> m_size;<br>    <span class="hljs-type">int</span>* m_data;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个成员方法都有调用了log方法，我们可以通过这样查看每个方法的调用情况。</p><p>首先，我们运行一个将v1实例的内容用重载后的&#x3D;号拷贝到v2的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">IntVec <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>IntVec v2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;assigning lvalue...\n&quot;</span>;<br>v2 = v1;<br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning lvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">assigning lvalue...<br>[0x28fef8] copy assignment operator<br>[0x28fec8] copy constructor<br>[0x28fec8] destructor<br>ended assigning lvalue...<br></code></pre></td></tr></table></figure><p>可以看到，首先调用了重载&#x3D;的方法，然后用拷贝构造方法构造tmp，swap数据，最后析构tmp。</p><p>十分正常，但是如果我们将一个右值赋值给v2。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;assigning rvalue...\n&quot;</span>;<br>v2 = <span class="hljs-built_in">IntVec</span>(<span class="hljs-number">33</span>);    <span class="hljs-comment">// IntVec(33)是一个右值</span><br>cout &lt;&lt; <span class="hljs-string">&quot;ended assigning rvalue...\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>这里虽然是自定义的类的右值，但是可以代表一般情况，也就是我们创建了一个临时的右值，例如数字，字符，字符串等，然后赋值给一个变量。我们会得到这样的输出。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">assigning rvalue...<br>[0x28ff08] constructor<br>[0x28fef8] copy assignment operator<br>[0x28fec8] copy constructor<br>[0x28fec8] destructor<br>[0x28ff08] destructor<br>ended assigning rvalue...<br></code></pre></td></tr></table></figure><p>这里就多了一些步骤了，首先调用构造方法构造了一个临时IntVec对象，这个对象是右值。然后用&#x3D;号重载将这个对象赋值给v2，但由于这个对象是右值，它是不可更改的，因此就还是和上面一样，再构造一个左值tmp储存数据，然后再通过swap才能将数据最终给v2。然后将tmp和临时对象都析构。</p><p>我们可以看到，为了将这个右值赋值给左值v2，我们在内存中创建了两个一模一样的对象，这完全是没有必要的。所以说，有没有什么办法，可以直接将临时变量赋值给v2呢？</p><p>因此，就出现了右值引用。右值引用是对右值的引用，用&amp;&amp;表示，我们可以在IntVec类的声明里再加入一个方法，用来重载参数是右值时的&#x3D;号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">IntVec&amp; <span class="hljs-keyword">operator</span>=(Intvec&amp;&amp; other)<br>&#123;<br>    <span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;move assignment operator&quot;</span>);<br>    std::<span class="hljs-built_in">swap</span>(m_size, other.m_size);<br>    std::<span class="hljs-built_in">swap</span>(m_data, other.m_data);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>借助右值引用可以为IntVec类添加移动构造方法，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。这时other是一个右值引用，我们可以直接将右值的值复制到当前的对象中，而不用再通过tmp进行中转。而且在调用结束后，右值引用就会被销毁。得到的输出是。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">assigning rvalue...<br>[0x28ff08] constructor<br>[0x28fef8] move assignment operator<br>[0x28ff08] destructor<br>ended assigning rvalue...<br></code></pre></td></tr></table></figure><p>这样一来，少了一次对象的创建和析构的过程，减少了内存的占用和运行时间。由于将一个右值赋值给了v2，移动赋值操作符被调用。虽然IntVec(33)仍然会创建一个临时对象，调用其构造器和析构器，但赋值操作符中的另一个临时对象不会再创建了。这个赋值操作符直接将右值的内部内容和自己的相交换，自己获得右值的内容，然后右值的析构器会销毁自己原先的内容，而这一内容已经不需要了。</p><p>右值引用和std::move()方法密不可分，我会在另一篇文章中介绍std::move()方法。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NL and PL</title>
    <link href="/2021/12/25/NL-and-PL/"/>
    <url>/2021/12/25/NL-and-PL/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.chakray.com/programming-languages-types-and-features/">https://www.chakray.com/programming-languages-types-and-features/</a>:</p><p>自然语言是人们说的语言，而编程语言是为了机器设计的。<br>Natural language is the language spoken by people, while programming language is intended for machines.</p><p>这两种语言都包含重要的相似之处，例如它们在语法和语义之间的区分，它们的交流目的和基本构成的存在。<br>Both languages contain important similarities, such as the differentiation they make between syntax and semantics, their purpose to communicate and the existence of a basic composition.</p><p>这两种类型是为了交流思想、表达和指示而产生的。<br>The two types were created to communicate ideas, expressions, and instructions.</p><p>编程语言更严格，也更不宽容。自然语言有内在的冗余，允许利用上下文来解决一些歧义。<br>the latter is stricter and less tolerant than the former. This happens because human languages have a built-in redundancy that allows some ambiguity to be resolved using context.</p><p>编程语言几乎没有冗余，否则就很容易陷入歧义，而无法指出正确的命令。<br>On the other hand, programming languages have practically no redundancy, otherwise, it would be very easy to fall into ambiguity and not indicate the correct command.</p><p>编程语言更严格的原因是计算机喜欢接受精确的指令，此外，机器没有能力像人一样澄清表达的含义。<br>The fact that programming languages are stricter in this regard is due to the fact that computers are very precise in the instructions they like to receive. In addition, machines do not have the ability to clarify the meaning of an expression as a human being would.</p><p>为了避免混淆，编程语言是固定的和封闭的，而自然语言是开放的，允许组合而不会有同样的出错风险。<br>It is also essential that programming languages are fixed and closed to avoid confusion, while natural languages are open and allow combinations without the same risk of making mistakes.</p><p>编程语言有意向特性，就是自然性，这意味着它在其设计领域的应用必须自然地进行，为操作者提供操作符、结构和语言，以便有效地工作。<br>Naturalness: this means that its application in the area for which it was designed must be done naturally, providing operators, structures and syntax for operators to work efficiently.</p><p><a href="https://www.quora.com/Whats-the-difference-between-natural-languages-and-programming-languages">https://www.quora.com/Whats-the-difference-between-natural-languages-and-programming-languages</a>:</p><p>Daniel Ross:</p><p>编程语言是确定的，明确的，毫不含糊的，而自然语言是多歧义的，往往是多重含糊的，需要在上下文中解释才能完全理解，<strong>这也是机器很难理解自然语言的原因</strong>。自然语言是富含创造性的，其允许诗歌，隐喻或者其它解释，编程语言确实允许在风格上有一些变化，但含义并不灵活。<br>Programming languages are unambiguous, while natural languages are often multiply ambiguous and require interpretation in context to be fully understood (also why it’s so hard to get machines to understand them). Natural languages are also creative and allow poetry, metaphor and other interpretations. Programming does allow some variation in style, but the meaning is not flexible.</p><p>自然语言由句子组成，通常是陈述性的句子，以序列的方式表达信息。编程语言通常不是陈述性的，而是程序性的，向机器发出指令去做一些事情（像自然语言中的命令）。很少有编程语言是陈述性的<br>Natural languages consist of sentences, usually declarative sentences expressing information in a sequence. Programming languages typically are not declarative but procedural, giving instructions to the machine to do something (like commands in natural languages). Rarely, programming languages are declarative</p><p>自然语言的词汇充满了概念性的术语。编程语言的词汇通常只有 “语法”&#x2F;功能 “词”，如基本注释，加上各种自定义命名的东西，如变量和函数。没有像你在字典里查到的表达 “爱 “或 “快乐 “或 “唱歌 “的词。<br>The vocabulary of natural languages is filled with conceptual terms. The vocabulary of programming languages is generally only ‘grammatical’&#x2F;functional ‘words’ like basic comments, plus various custom-named things like variables and functions. There are no words like you’d look up in a dictionary to express something like ‘love’ or ‘happy’ or ‘sing’.</p><p>语法结构的变化比在这里列出的要多。但一些最明显的因素是，在编程语言中，单词没有可分离的部分（如英语cat-s组成复数）（&#x3D;没有形态）<em>（注：但是编程语言中有另一种可分离的形式，就是自定义的标识符，驼峰&#x2F;下划线命名法）</em>，而且通过括号、换行符或其他标记，嵌入往往在编程语言的两边都有明显的标记，而口语通常只有一个词（如 “that”）连接嵌入的句子，有时甚至没有词。这也是在计算机上解析人类语言如此困难的另一个原因。<br>The grammatical structures vary in more ways than are easy to list here. But some of the most obvious factors are that words don’t have separable parts in programming languages (like English cat-s to form a plural) [&#x3D;no morphology], and that via brackets, line breaks or other markers, embedding tends to be overtly and clearly marked on both sides for the parser in programming languages, whereas spoken languages usually only have one word (like “that”) linking embedded sentences, and sometimes no word at all. This is another reason that parsing human languages is so hard on a computer.</p><p>在一个非常普遍的意义上，编程语言并不用于双向交流，而且可能不适合被视为与自然语言相同意义上的 “语言”。<br>In a very general sense, programming languages aren’t used for bidirectional communication and may not properly be considered “languages” in the same sense as natural languages.</p><p>最根本的是，值得一问的是，编程语言是否有意义，或者它们是否只是指令。这类似于中国房间的思想实验–给你一本关于如何翻译中文的说明，但没有真正理解它，拿着这本书的人（或计算机）会被认为 “知道 “中文吗？可能不会。计算机并不 “了解 “任何东西，它只是做指令所要求的。因此，编程语言没有语义&#x2F;意义。它们只是指令，可以转化为电子信号，仅此而已。<br>Most fundamentally, it is worth asking if programming languages even have meaning, or if they are just instructions. This is similar to the Chinese room thought experiment— given a book of instructions for how to translate Chinese, but without actually understanding it, would a human (or computer) with that book be considered to “know” Chinese? Probably not. A computer doesn’t “know” anything, it just does what the instructions tell it to. Therefore, programming languages have no semantics&#x2F;meaning. They just are instructions, which translate into electronic signals, nothing more.<br><em>注：可以理解为，编程语言本身没有任何语义，但是人们在编写编程语言的时候，人工赋予了这一段代码一些语义信息，例如变量名，对于计算机而言，变量名确实只是一个符号，而对于阅读这段代码的人来说，变量名确实给了他一定的语义信息。因此，对于应用NLP方法真正理解这段代码来说，利用代码里的语义信息，是否是个正确的选择。</em></p><p>Torben Ægidius Mogensen: </p><p>编程语言是先验的，而自然语言根据其使用情况而定义。<br>programming languages are specified a priori, where natural languages are described based on their usage.</p><p>这有几个后果。其一是自然语言中一个短语的含义可能不会被普遍认同，甚至可能随着时间的推移而改变。在编程语言中，一个短语的含义只有一个（如果语言设计者做得好的话），而且通常不会随着时间的推移而改变–新的结构体可能会被添加，但旧的结构体很少会改变含义。<br>This has several consequences: One is that the meaning of a phrase in natural language may not be universally agreed upon, and may even change over time. The meaning of a phrase in a programming language has only one meaning (if the language designers did their job well), and it will usually not change over time — new constructs may be added, but old constructs rarely change meaning.</p><p>前面的一个答案说，编程语言是为了让机器理解而设计的。我并不同意。编程语言是为人们阅读和书写而设计的，在机器能够理解它们之前需要进行翻译。我们不使用自然语言为计算机编程的主要原因是，人类在用自然语言毫不含糊地、精确地表达自己方面是出了名的糟糕。<br>One of the earlier answers said that programming languages are designed to be understood by machines. I do not agree: Programming languages are designed for people to read and write, and need to be translated before machines can understand them. The main reason we do not use natural language to program computers is that humans are notoriously bad at expressing themselves unambiguously and precisely in natural languages.</p><p><a href="https://www.quora.com/What-are-the-fundamental-differences-between-a-human-language-and-a-computer-language">https://www.quora.com/What-are-the-fundamental-differences-between-a-human-language-and-a-computer-language</a>:</p><p>Bruce Richardson:</p><p>人类语言比编程语言更复杂。句法和语法更复杂，语义更细微，词汇量大得多。<br>Human languages are more complex than programming languages. The syntax and grammar is more complex, the semantics more nuanced, the vocabulary much larger.</p><p>Greg Kemnitz:</p><p>除了形式化语法之类的技术方面，计算机语言没有外部环境。<br>In addition to the technical aspects of formal grammars and such things, a computer language has no external context.</p><p>人类的语言充满了寓言、类比以及历史和文化参考，使一个短语或一个词能够承载巨大的意义。你如何用计算机语言表达 “跨越卢比肯河”、”咬苹果”、”红色药丸 “或 “我有一个梦想”？<br>A human language is full of allegory, analogy, and historical and cultural references that allow a short phrase or a word to carry vast weight of meaning. How do you express “crossing the Rubicon”, “biting the apple”, “the red pill”, or “I have a dream” in a computer language?</p><p>一个计算机程序必须是完全自我定义的。与 “类比 “或 “引用 “最接近的可能是操作系统服务或计算机程序使用但不试图实现的外部工具，但即使是这样，该服务也必须在计算机程序的操作环境中完全实现和定义好，否则它就没有功能。<br>A computer program must be completely self-defining. The closest equivalent to “analogies’ or “references” might be OS services or external utilities that the computer program uses but does not attempt to implement, but even there, the service must be completely implemented and well-defined in the operating environment of the computer program, or it is nonfunctional.</p><p><a href="https://medium.com/@anaharris/human-languages-vs-programming-languages-c89410f13252">https://medium.com/@anaharris/human-languages-vs-programming-languages-c89410f13252</a>:</p><p>我们已经从上一段中得到了这个信息，但让我们再重复一遍：语言的主要功能，无论是Python还是中文，都是交流。这是它们之间最重要的相似之处，也是我们把它们都称为语言的主要原因之一。<br>We already got this from the previous paragraph, but let’s repeat it again: the main function of languages, be it Python or Chinese, is communication. This is the most important similarity between them, and one of the main reasons we refer to both of them as languages.</p><p>它们的另一个重要的共同特征是结构。语言学中的两个主要概念是语义学和句法。<br>Another important feature that they have in common is structure. Two of the main concepts in linguistics are semantics and syntax.</p><p>语义学指的是某个词的含义，或者说是与某个概念相关的信息。例如，吃这个词适用于生物体能做的特定动作。<br>Semantics refers to the meaning of a certain word, or rather an information connected to a certain concept. For example, a word eat applies to a specific action living organisms can do.</p><p>另一方面，句法是一套规则，告诉我们如何安排和组合单词和短语。<br>Syntax, on the other hand, is a set of rules that tell us how to arrange and combine words and phrases.</p><p>两者紧密相连，只有结合在一起才能创造出一个功能齐全的表达。以一个句子 “床吃东西 “为例：虽然从语法的角度看它是正确的，但从语义上看它是错误的，因为床没有生命，所以不能吃东西。<br>The two are closely intwined and only together can create a fully functioning expression. Take a sentence Bed eats as an example: while it’s correct from the point of view of a syntax, semantically it’s wrong since a bed is not alive and therefore cannot eat.</p><p>与自然语言类似，编程语言也区分了语法和语义。每一种编程语言都是以某种想法或意图为基础编写的（语义），同时遵循围绕变量、函数、不同种类的括号、冒号等的使用规则。(语法）。<br>Similarly to natural languages, programming languages distinguish between syntax and semantics. Every programming language is written with a certain idea or intention in mind (semantics) while following the set of rules around the use of variables, functions, different kinds of parenthesis, colons, etc. (syntax).</p><p>同样重要的是要指出，这两种语言都形成了语系，或者说是由一个个相关语言组成的群体。我们都听说过印欧语系，它包括英语和其他许多语言。编程语言也有自己的语言家族，其语法和&#x2F;或语义相对相似。<br>It is also important to point out that both form language families, or groups of related languages that branch one from another. We all have heard of the Indo-European language family, that includes English, among many other languages. Programming languages have their own families of language with relatively similar syntax and&#x2F;or semantics.</p><p>在谈到语言的结构时，我们不要忘记提到形态学。语态学是研究单词、它们的形成、它们与同一语言中其他单词的关系，以及语境改变一个单词的发音和含义的方式。虽然形态学在人类语言的分析中起着非常重要的作用，但我们真的不能说编程语言有类似的东西。<br>While speaking about the structure of languages, let’s not forget to mention morphology. Morphology is the study of words, their formation, their relationship with other words in the same language, as well as the ways context can change a word’s pronunciation and meaning. While morphology plays a very important role in the analysis of human languages, we can’t really say that programming languages have anything similar to it.</p><p>首先，编程语言是人工创造的。这意味着它们所有的规则和定义都是事先设计好的，这使得它们可以被完整地描述和研究。它们的语法是自我定义的，而且不会因上下文而改变。这样想吧：每一行代码要么是零，要么是一个意思（换句话说，它要么包含一个错误，要么是一个你可以运行的有效程序）。没有同义词（尽管Ruby的.map和.collect可以被看作是同义词，例如）、寓言、比喻、历史或文化参考。正因为如此，编程语言并没有真正的形态学，至少没有像人类语言那样。<br>First of all, programming languages are artificial creations. This means that all of their rules and definitions were designed beforehand, which allows for them to be fully described and studied in their entirety. Their grammar is self-defining, and it doesn’t change depending on the context. Think about it this way: every line of code has either zero or one meaning (in other words, it either contains an error or it’s a valid program you can run). There are no synonyms (although Ruby’s .map and .collect could be seen as synonyms, for example), allegories, analogies, historical or cultural references. Because of this, programming languages don’t really have morphology, at least not the same way human languages do.</p><p>第二，由于它们遵循非常严格的规则，编程语言不能像人类语言那样进化和发展（尽管我们可以说编程语言是通过各种库进化的）。没有错误或即兴发挥的空间。另一方面，人类语言充满了不完善之处。只要想想方言、俚语、行话、论语（某个群体使用的、外人无法理解的秘密语言）、命名、口音、发音错误的单词、打字错误、不规则的标点符号以及人类语言的许多其他方面，都不会破坏我们要传达的信息。<br>Second, due to the fact that they follow very strict set of rules, programming languages can’t evolve and develop the same way human languages do (although we could say that programming languages evolve through various libraries). There’s no room for errors or improvisation. On the other hand, human languages are full of imperfections. Just think of dialects, slang, jargon, argot (secret language used by a certain group that’s incomprehensible to outsiders), namesake, accents, mispronounced words, typos, irregular punctuation and many other aspects of human languages that don’t disrupt the message we’re trying to communicate.</p><p>而人类语言所传达的信息既是逻辑的，也是情感的。如果是口语，它涉及身体语言、语调、音量和许多其他非语言线索。事实上，语言在很大程度上是由人类身体的物理属性（眼睛、舌头、手）来定义的，也正因为如此，它是人类独有的。这些都不适用于编程语言。尽管技术高超的程序员可以开发出他们自己的代码编写风格，但代码的性质仍然是一样的：逻辑性强、精确、完全不含糊。这并不令人惊讶，因为所有编程语言的基础是数十亿的1和0。<br>And the message human languages communicate is both logical and emotional. If spoken, it involves body language, intonation, volume, and many other nonverbal clues. In fact, languages are much defined by the physical attributes of human bodies (eyes, tongue, hands), and are for that reason unique to humans. None of these applies to programming languages. Although highly skilled programmers can develop their own styles of writing code, the nature of that code remains the same: logical, precise, perfectly unambiguous. Which shouldn’t come as a surprise, since the foundation of all programming languages are billions and billions of 1s and 0s.</p><p><a href="https://technologyguider.com/what-is-difference-between-programming-language-and-natural-language/">https://technologyguider.com/what-is-difference-between-programming-language-and-natural-language/</a>:</p><p>在语法方面，这些语言也是彼此不同的。编程措辞不遵循任何语法规则。这个概念只存在于人类身上。<br>These languages are also different from one another in the case of grammar. Programming wording does not follow any of the grammar rules. This concept is only in humans. </p><p>如果有人想在编程中实现语法，那么代码将无法工作，因为计算机不理解人在说什么。<br>If anyone wanted to implement grammar in programming then the code will not work because the computer is not understanding that what a person is saying.</p><p>编程的句子不依赖于语法，只有人类的句子才依赖于语法。<br>Programming sentences are not dependent on grammar only humans’ sentences are dependent on it.</p><p>就句子而言，它是自然语言的唯一概念。在编程语言中，没有句子的概念。因为所有的信息都是由几个词覆盖的。如果你在一行中写一个大的代码，使其成为一个句子，那么它将无法工作。<br>In the case of sentences, it is the only concept of natural languages. In programming languages, there is no concept of sentences. Because all the information is covered by few words. If you will write a big code in one line to make it a sentence then it will not work.</p><p><a href="http://meetrajesh.com/posts/natural-vs-programming-languages.html">http://meetrajesh.com/posts/natural-vs-programming-languages.html</a>:</p><p>这两种形式在非常基本的层面上仍然是语言，而不仅仅是名称上。它们在本质上都是为了实现一个目标而创造的：交流。特别是，交流思想和表达方式。在某些情况下，还有指令。<br>The two forms are still languages at a very fundamental level, not just by name. They were both essentially created to achieve one goal: to communicate. In particular, to communicate ideas and expressions. And in some cases, instructions.</p>]]></content>
    
    
    <categories>
      
      <category>Discussion</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Discussion</tag>
      
      <tag>Software Engineering</tag>
      
      <tag>Source Code</tag>
      
      <tag>Natural Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Threats to Validity</title>
    <link href="/2021/08/29/threats-to-validity/"/>
    <url>/2021/08/29/threats-to-validity/</url>
    
    <content type="html"><![CDATA[<p>软件工程领域里的很多论文在最后都会有Threats to Validity，之前读论文的时候都是一眼带过。自己曾经写过，也是随便写写。前几天写论文写到这一章，仔细去看了一些论文，发现这也分很多种类。搜了一下，发现还有一篇论文是专门对这个的研究。所以在这里就依据这篇论文做一个总结吧。由于现在我的研究方向是机器学习，所以就结合这个方向进行讨论。这些都是我所理解的，可能不严谨，也可能不正确。</p><p>作者首先强调了一些概念，有效性(validity)关心的是得出的结论怎样可能会错，也就是说，结论和现实之间的关系。它和质量(quality)不同，质量比有效性大很多，例如可复现性(replicability)就属于一个研究的质量，而不是有效性。另外，有效性是一个目标。一个有效性威胁(validity threat, VT)就是一个在前往目标时，你可能会出错的路径。</p><p>作者将Threats to Validity分成了以下几类：</p><h2 id="Conclusion-Validity"><a href="#Conclusion-Validity" class="headerlink" title="Conclusion Validity"></a>Conclusion Validity</h2><p>大多数人都认为结论有效性是特指“统计”学上的有效性，其实并不是，几乎所有工作都会有结论有效性（只要你得出结论了）。结论有效性是指我们从数据的关系中得出的结论的合理程度。只要你的论文是在说明某种关系，那么结论无非就是两种结果，有关系或没有关系。无论是哪种情况，得出的结论都有可能是错的。有可能本来没有关系，你的结论是有关系，也有可能本来有关系，只是你没有发现而已。结论有效性就是在讨论这种可能性。</p><p>举个例子，如果你通过统计一些数据发现学校中参加某一个项目的学生成绩都很高，其他学生的成绩都很低。结论有效性就是根据这些数据就得出这样结论的合理性。也许参加这个项目并不是原因而是结果（可能参加项目的门槛就是成绩优秀），也许这些学生本来就比对照组聪明，这就导致了结论的不合理性。</p><p>在机器学习中，大部分时间就是在提出一个新的方法，通过实验来证明这种方法可以达到更好的效果。这本质上也是在证明你提出的方法和更好的结果之间存在必然的关系。所以，这时结论有效性就应该讨论你所提出的方法是否是导致更好效果的原因。也就是说，到底是你提出的方法导致结果变好，还是有可能是由于其它的原因导致结果变好。</p><p>不过在机器学习中，这个类别不是经常被讨论，因为你可以通过消融实验(ablation study)来证明你提出的方法的有效性。</p><h2 id="Internal-Validity"><a href="#Internal-Validity" class="headerlink" title="Internal Validity"></a>Internal Validity</h2><p>内部有效性就是说采用方法的内部的有效性，所以，讨论内部有效性的前提是，已经有证据证明所采用的方法对最终的结果有影响。有人说结论有效性是内部有效性的特例，但是当它们两个分开的时候，内部有效性更多地关注于方法内部。下图就形象地表达了内部有效性。<br><img src="/img/posts/threats/internal_validity.gif" alt="内部有效性"></p><p>机器学习中的内部有效性最常见的是超参数的设置了，超参数的不同可能会导致结果的偏差。这也很好理解，你提出了新的方法，或者改进，你实现的方法和别人实现的方法肯定不完全相同。就算你是在某个方法上进行的更改，那么你也不能保证其它对比的方法都是在一个代码上进行的更改。所以，你用了你的方法，同时也引入了其它的不可预期的变量。有时候看似你的方法，模型效果很好，但可能是超参数的原因。除非你有大规模的调参，或者在所有的实验上，包括对比方法的参数、技巧（例如warmup等提分的技巧）都设置成一模一样（通常来说不太可能实现），那么内部有效性都会超参数这一项。</p><h2 id="Construct-Validity"><a href="#Construct-Validity" class="headerlink" title="Construct Validity"></a>Construct Validity</h2><p>在论文中，我们都会基于一个理论，提出一种方法，然后通过对这个方法观测到的结果，来进行推论，从基于的这个理论，推理到结果所基于的理论。因此就会存在两种结界：第一种是观测到的结界，从提出的方法到观测到的实验结果；另一种是理论的结界，从提出方法基于的理论到结果的理论。通过下图可以很直观地看到。<br><img src="/img/posts/threats/construct_validity.gif" alt="结构有效性"></p><p>我们所能保证的是下面的，观测到的是真实的，但是无法保证你所说明的，基于观测到的理论的完全正确性，包括两个结界之间的联系，以及理论中Cause Construct到Effect Construct的推论是否正确。所以，结构有效性关注的就是你所基于的，解释的理论是否是正确的。</p><p>例如，你为了证明一个新的学习桌对小学生的成绩有提升的作用，你为它们换上了学习桌。这么看来你所做的改变仅仅是书桌，而最终的结果也证明了你的猜想。但是有可能是你错了，学生成绩提高的原因是它得到了更多的关注。所以，你虽然改变的仅仅是书桌，但是改变书桌所带来的其它不可预期的变化，可能导致你得出错误的结论。</p><p>机器学习中，举一个例子就是我如果用自监督学习来提高某一个任务的性能。最后实验也证明了使用自监督学习可以提升结果。但是自监督使用的数据集里面包括了下游任务的测试集中的数据，那么这就叫结构有效性。</p><p>有人可能会混淆内部有效性和结构有效性，我的理解是，内部有效性关注的是是你在实践中引入的其它因子，而结构有效性指的是在依据理论进行实践时，这个从理论到实践的环节，是否是一一对应的。拿很火的Transformer举例，作者认为RNN不能并行计算，速度很慢，而且对长序列依赖来说效果不好，因此提出了Transformer模型，最终发现Transformer的结果要比RNN更好，速度更快。所以这里的内部有效性就是实验中使用的Transformer是否和对比的RNN一样的超参数设置，并且模型大小是否相当，其它的各种变量都相同。而结构有效性就是Transformer是否是像作者解释的那样，速度快是因为使用了多头注意力机制，从而可以并行，而不是另外的原因。</p><h2 id="External-Validity"><a href="#External-Validity" class="headerlink" title="External Validity"></a>External Validity</h2><p>简单来说外部有效性就是泛化性。关注的是样本是否代表所有情况，在其它情况下的是否还会得到相同的结果。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Feldt, Robert, and Ana Magazinius. “Validity Threats in Empirical Software Engineering Research-An Initial Survey.”</p>]]></content>
    
    
    <categories>
      
      <category>Paper Writing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Software Engineering</tag>
      
      <tag>Paper Writing</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
