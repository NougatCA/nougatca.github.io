<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/01/03/hello-world/"/>
    <url>/2023/01/03/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NL and PL</title>
    <link href="/2021/12/25/NL-and-PL/"/>
    <url>/2021/12/25/NL-and-PL/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.chakray.com/programming-languages-types-and-features/">https://www.chakray.com/programming-languages-types-and-features/</a>:</p><p>自然语言是人们说的语言，而编程语言是为了机器设计的。<br>Natural language is the language spoken by people, while programming language is intended for machines.</p><p>这两种语言都包含重要的相似之处，例如它们在语法和语义之间的区分，它们的交流目的和基本构成的存在。<br>Both languages contain important similarities, such as the differentiation they make between syntax and semantics, their purpose to communicate and the existence of a basic composition.</p><p>这两种类型是为了交流思想、表达和指示而产生的。<br>The two types were created to communicate ideas, expressions, and instructions.</p><p>编程语言更严格，也更不宽容。自然语言有内在的冗余，允许利用上下文来解决一些歧义。<br>the latter is stricter and less tolerant than the former. This happens because human languages have a built-in redundancy that allows some ambiguity to be resolved using context.</p><p>编程语言几乎没有冗余，否则就很容易陷入歧义，而无法指出正确的命令。<br>On the other hand, programming languages have practically no redundancy, otherwise, it would be very easy to fall into ambiguity and not indicate the correct command.</p><p>编程语言更严格的原因是计算机喜欢接受精确的指令，此外，机器没有能力像人一样澄清表达的含义。<br>The fact that programming languages are stricter in this regard is due to the fact that computers are very precise in the instructions they like to receive. In addition, machines do not have the ability to clarify the meaning of an expression as a human being would.</p><p>为了避免混淆，编程语言是固定的和封闭的，而自然语言是开放的，允许组合而不会有同样的出错风险。<br>It is also essential that programming languages are fixed and closed to avoid confusion, while natural languages are open and allow combinations without the same risk of making mistakes.</p><p>编程语言有意向特性，就是自然性，这意味着它在其设计领域的应用必须自然地进行，为操作者提供操作符、结构和语言，以便有效地工作。<br>Naturalness: this means that its application in the area for which it was designed must be done naturally, providing operators, structures and syntax for operators to work efficiently.</p><p><a href="https://www.quora.com/Whats-the-difference-between-natural-languages-and-programming-languages">https://www.quora.com/Whats-the-difference-between-natural-languages-and-programming-languages</a>:</p><p>Daniel Ross:</p><p>编程语言是确定的，明确的，毫不含糊的，而自然语言是多歧义的，往往是多重含糊的，需要在上下文中解释才能完全理解，<strong>这也是机器很难理解自然语言的原因</strong>。自然语言是富含创造性的，其允许诗歌，隐喻或者其它解释，编程语言确实允许在风格上有一些变化，但含义并不灵活。<br>Programming languages are unambiguous, while natural languages are often multiply ambiguous and require interpretation in context to be fully understood (also why it’s so hard to get machines to understand them). Natural languages are also creative and allow poetry, metaphor and other interpretations. Programming does allow some variation in style, but the meaning is not flexible.</p><p>自然语言由句子组成，通常是陈述性的句子，以序列的方式表达信息。编程语言通常不是陈述性的，而是程序性的，向机器发出指令去做一些事情（像自然语言中的命令）。很少有编程语言是陈述性的<br>Natural languages consist of sentences, usually declarative sentences expressing information in a sequence. Programming languages typically are not declarative but procedural, giving instructions to the machine to do something (like commands in natural languages). Rarely, programming languages are declarative</p><p>自然语言的词汇充满了概念性的术语。编程语言的词汇通常只有 “语法”&#x2F;功能 “词”，如基本注释，加上各种自定义命名的东西，如变量和函数。没有像你在字典里查到的表达 “爱 “或 “快乐 “或 “唱歌 “的词。<br>The vocabulary of natural languages is filled with conceptual terms. The vocabulary of programming languages is generally only ‘grammatical’&#x2F;functional ‘words’ like basic comments, plus various custom-named things like variables and functions. There are no words like you’d look up in a dictionary to express something like ‘love’ or ‘happy’ or ‘sing’.</p><p>语法结构的变化比在这里列出的要多。但一些最明显的因素是，在编程语言中，单词没有可分离的部分（如英语cat-s组成复数）（&#x3D;没有形态）<em>（注：但是编程语言中有另一种可分离的形式，就是自定义的标识符，驼峰&#x2F;下划线命名法）</em>，而且通过括号、换行符或其他标记，嵌入往往在编程语言的两边都有明显的标记，而口语通常只有一个词（如 “that”）连接嵌入的句子，有时甚至没有词。这也是在计算机上解析人类语言如此困难的另一个原因。<br>The grammatical structures vary in more ways than are easy to list here. But some of the most obvious factors are that words don’t have separable parts in programming languages (like English cat-s to form a plural) [&#x3D;no morphology], and that via brackets, line breaks or other markers, embedding tends to be overtly and clearly marked on both sides for the parser in programming languages, whereas spoken languages usually only have one word (like “that”) linking embedded sentences, and sometimes no word at all. This is another reason that parsing human languages is so hard on a computer.</p><p>在一个非常普遍的意义上，编程语言并不用于双向交流，而且可能不适合被视为与自然语言相同意义上的 “语言”。<br>In a very general sense, programming languages aren’t used for bidirectional communication and may not properly be considered “languages” in the same sense as natural languages.</p><p>最根本的是，值得一问的是，编程语言是否有意义，或者它们是否只是指令。这类似于中国房间的思想实验–给你一本关于如何翻译中文的说明，但没有真正理解它，拿着这本书的人（或计算机）会被认为 “知道 “中文吗？可能不会。计算机并不 “了解 “任何东西，它只是做指令所要求的。因此，编程语言没有语义&#x2F;意义。它们只是指令，可以转化为电子信号，仅此而已。<br>Most fundamentally, it is worth asking if programming languages even have meaning, or if they are just instructions. This is similar to the Chinese room thought experiment— given a book of instructions for how to translate Chinese, but without actually understanding it, would a human (or computer) with that book be considered to “know” Chinese? Probably not. A computer doesn’t “know” anything, it just does what the instructions tell it to. Therefore, programming languages have no semantics&#x2F;meaning. They just are instructions, which translate into electronic signals, nothing more.<br><em>注：可以理解为，编程语言本身没有任何语义，但是人们在编写编程语言的时候，人工赋予了这一段代码一些语义信息，例如变量名，对于计算机而言，变量名确实只是一个符号，而对于阅读这段代码的人来说，变量名确实给了他一定的语义信息。因此，对于应用NLP方法真正理解这段代码来说，利用代码里的语义信息，是否是个正确的选择。</em></p><p>Torben Ægidius Mogensen: </p><p>编程语言是先验的，而自然语言根据其使用情况而定义。<br>programming languages are specified a priori, where natural languages are described based on their usage.</p><p>这有几个后果。其一是自然语言中一个短语的含义可能不会被普遍认同，甚至可能随着时间的推移而改变。在编程语言中，一个短语的含义只有一个（如果语言设计者做得好的话），而且通常不会随着时间的推移而改变–新的结构体可能会被添加，但旧的结构体很少会改变含义。<br>This has several consequences: One is that the meaning of a phrase in natural language may not be universally agreed upon, and may even change over time. The meaning of a phrase in a programming language has only one meaning (if the language designers did their job well), and it will usually not change over time — new constructs may be added, but old constructs rarely change meaning.</p><p>前面的一个答案说，编程语言是为了让机器理解而设计的。我并不同意。编程语言是为人们阅读和书写而设计的，在机器能够理解它们之前需要进行翻译。我们不使用自然语言为计算机编程的主要原因是，人类在用自然语言毫不含糊地、精确地表达自己方面是出了名的糟糕。<br>One of the earlier answers said that programming languages are designed to be understood by machines. I do not agree: Programming languages are designed for people to read and write, and need to be translated before machines can understand them. The main reason we do not use natural language to program computers is that humans are notoriously bad at expressing themselves unambiguously and precisely in natural languages.</p><p><a href="https://www.quora.com/What-are-the-fundamental-differences-between-a-human-language-and-a-computer-language">https://www.quora.com/What-are-the-fundamental-differences-between-a-human-language-and-a-computer-language</a>:</p><p>Bruce Richardson:</p><p>人类语言比编程语言更复杂。句法和语法更复杂，语义更细微，词汇量大得多。<br>Human languages are more complex than programming languages. The syntax and grammar is more complex, the semantics more nuanced, the vocabulary much larger.</p><p>Greg Kemnitz:</p><p>除了形式化语法之类的技术方面，计算机语言没有外部环境。<br>In addition to the technical aspects of formal grammars and such things, a computer language has no external context.</p><p>人类的语言充满了寓言、类比以及历史和文化参考，使一个短语或一个词能够承载巨大的意义。你如何用计算机语言表达 “跨越卢比肯河”、”咬苹果”、”红色药丸 “或 “我有一个梦想”？<br>A human language is full of allegory, analogy, and historical and cultural references that allow a short phrase or a word to carry vast weight of meaning. How do you express “crossing the Rubicon”, “biting the apple”, “the red pill”, or “I have a dream” in a computer language?</p><p>一个计算机程序必须是完全自我定义的。与 “类比 “或 “引用 “最接近的可能是操作系统服务或计算机程序使用但不试图实现的外部工具，但即使是这样，该服务也必须在计算机程序的操作环境中完全实现和定义好，否则它就没有功能。<br>A computer program must be completely self-defining. The closest equivalent to “analogies’ or “references” might be OS services or external utilities that the computer program uses but does not attempt to implement, but even there, the service must be completely implemented and well-defined in the operating environment of the computer program, or it is nonfunctional.</p><p><a href="https://medium.com/@anaharris/human-languages-vs-programming-languages-c89410f13252">https://medium.com/@anaharris/human-languages-vs-programming-languages-c89410f13252</a>:</p><p>我们已经从上一段中得到了这个信息，但让我们再重复一遍：语言的主要功能，无论是Python还是中文，都是交流。这是它们之间最重要的相似之处，也是我们把它们都称为语言的主要原因之一。<br>We already got this from the previous paragraph, but let’s repeat it again: the main function of languages, be it Python or Chinese, is communication. This is the most important similarity between them, and one of the main reasons we refer to both of them as languages.</p><p>它们的另一个重要的共同特征是结构。语言学中的两个主要概念是语义学和句法。<br>Another important feature that they have in common is structure. Two of the main concepts in linguistics are semantics and syntax.</p><p>语义学指的是某个词的含义，或者说是与某个概念相关的信息。例如，吃这个词适用于生物体能做的特定动作。<br>Semantics refers to the meaning of a certain word, or rather an information connected to a certain concept. For example, a word eat applies to a specific action living organisms can do.</p><p>另一方面，句法是一套规则，告诉我们如何安排和组合单词和短语。<br>Syntax, on the other hand, is a set of rules that tell us how to arrange and combine words and phrases.</p><p>两者紧密相连，只有结合在一起才能创造出一个功能齐全的表达。以一个句子 “床吃东西 “为例：虽然从语法的角度看它是正确的，但从语义上看它是错误的，因为床没有生命，所以不能吃东西。<br>The two are closely intwined and only together can create a fully functioning expression. Take a sentence Bed eats as an example: while it’s correct from the point of view of a syntax, semantically it’s wrong since a bed is not alive and therefore cannot eat.</p><p>与自然语言类似，编程语言也区分了语法和语义。每一种编程语言都是以某种想法或意图为基础编写的（语义），同时遵循围绕变量、函数、不同种类的括号、冒号等的使用规则。(语法）。<br>Similarly to natural languages, programming languages distinguish between syntax and semantics. Every programming language is written with a certain idea or intention in mind (semantics) while following the set of rules around the use of variables, functions, different kinds of parenthesis, colons, etc. (syntax).</p><p>同样重要的是要指出，这两种语言都形成了语系，或者说是由一个个相关语言组成的群体。我们都听说过印欧语系，它包括英语和其他许多语言。编程语言也有自己的语言家族，其语法和&#x2F;或语义相对相似。<br>It is also important to point out that both form language families, or groups of related languages that branch one from another. We all have heard of the Indo-European language family, that includes English, among many other languages. Programming languages have their own families of language with relatively similar syntax and&#x2F;or semantics.</p><p>在谈到语言的结构时，我们不要忘记提到形态学。语态学是研究单词、它们的形成、它们与同一语言中其他单词的关系，以及语境改变一个单词的发音和含义的方式。虽然形态学在人类语言的分析中起着非常重要的作用，但我们真的不能说编程语言有类似的东西。<br>While speaking about the structure of languages, let’s not forget to mention morphology. Morphology is the study of words, their formation, their relationship with other words in the same language, as well as the ways context can change a word’s pronunciation and meaning. While morphology plays a very important role in the analysis of human languages, we can’t really say that programming languages have anything similar to it.</p><p>首先，编程语言是人工创造的。这意味着它们所有的规则和定义都是事先设计好的，这使得它们可以被完整地描述和研究。它们的语法是自我定义的，而且不会因上下文而改变。这样想吧：每一行代码要么是零，要么是一个意思（换句话说，它要么包含一个错误，要么是一个你可以运行的有效程序）。没有同义词（尽管Ruby的.map和.collect可以被看作是同义词，例如）、寓言、比喻、历史或文化参考。正因为如此，编程语言并没有真正的形态学，至少没有像人类语言那样。<br>First of all, programming languages are artificial creations. This means that all of their rules and definitions were designed beforehand, which allows for them to be fully described and studied in their entirety. Their grammar is self-defining, and it doesn’t change depending on the context. Think about it this way: every line of code has either zero or one meaning (in other words, it either contains an error or it’s a valid program you can run). There are no synonyms (although Ruby’s .map and .collect could be seen as synonyms, for example), allegories, analogies, historical or cultural references. Because of this, programming languages don’t really have morphology, at least not the same way human languages do.</p><p>第二，由于它们遵循非常严格的规则，编程语言不能像人类语言那样进化和发展（尽管我们可以说编程语言是通过各种库进化的）。没有错误或即兴发挥的空间。另一方面，人类语言充满了不完善之处。只要想想方言、俚语、行话、论语（某个群体使用的、外人无法理解的秘密语言）、命名、口音、发音错误的单词、打字错误、不规则的标点符号以及人类语言的许多其他方面，都不会破坏我们要传达的信息。<br>Second, due to the fact that they follow very strict set of rules, programming languages can’t evolve and develop the same way human languages do (although we could say that programming languages evolve through various libraries). There’s no room for errors or improvisation. On the other hand, human languages are full of imperfections. Just think of dialects, slang, jargon, argot (secret language used by a certain group that’s incomprehensible to outsiders), namesake, accents, mispronounced words, typos, irregular punctuation and many other aspects of human languages that don’t disrupt the message we’re trying to communicate.</p><p>而人类语言所传达的信息既是逻辑的，也是情感的。如果是口语，它涉及身体语言、语调、音量和许多其他非语言线索。事实上，语言在很大程度上是由人类身体的物理属性（眼睛、舌头、手）来定义的，也正因为如此，它是人类独有的。这些都不适用于编程语言。尽管技术高超的程序员可以开发出他们自己的代码编写风格，但代码的性质仍然是一样的：逻辑性强、精确、完全不含糊。这并不令人惊讶，因为所有编程语言的基础是数十亿的1和0。<br>And the message human languages communicate is both logical and emotional. If spoken, it involves body language, intonation, volume, and many other nonverbal clues. In fact, languages are much defined by the physical attributes of human bodies (eyes, tongue, hands), and are for that reason unique to humans. None of these applies to programming languages. Although highly skilled programmers can develop their own styles of writing code, the nature of that code remains the same: logical, precise, perfectly unambiguous. Which shouldn’t come as a surprise, since the foundation of all programming languages are billions and billions of 1s and 0s.</p><p><a href="https://technologyguider.com/what-is-difference-between-programming-language-and-natural-language/">https://technologyguider.com/what-is-difference-between-programming-language-and-natural-language/</a>:</p><p>在语法方面，这些语言也是彼此不同的。编程措辞不遵循任何语法规则。这个概念只存在于人类身上。<br>These languages are also different from one another in the case of grammar. Programming wording does not follow any of the grammar rules. This concept is only in humans. </p><p>如果有人想在编程中实现语法，那么代码将无法工作，因为计算机不理解人在说什么。<br>If anyone wanted to implement grammar in programming then the code will not work because the computer is not understanding that what a person is saying.</p><p>编程的句子不依赖于语法，只有人类的句子才依赖于语法。<br>Programming sentences are not dependent on grammar only humans’ sentences are dependent on it.</p><p>就句子而言，它是自然语言的唯一概念。在编程语言中，没有句子的概念。因为所有的信息都是由几个词覆盖的。如果你在一行中写一个大的代码，使其成为一个句子，那么它将无法工作。<br>In the case of sentences, it is the only concept of natural languages. In programming languages, there is no concept of sentences. Because all the information is covered by few words. If you will write a big code in one line to make it a sentence then it will not work.</p><p><a href="http://meetrajesh.com/posts/natural-vs-programming-languages.html">http://meetrajesh.com/posts/natural-vs-programming-languages.html</a>:</p><p>这两种形式在非常基本的层面上仍然是语言，而不仅仅是名称上。它们在本质上都是为了实现一个目标而创造的：交流。特别是，交流思想和表达方式。在某些情况下，还有指令。<br>The two forms are still languages at a very fundamental level, not just by name. They were both essentially created to achieve one goal: to communicate. In particular, to communicate ideas and expressions. And in some cases, instructions.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈Threats to Validity</title>
    <link href="/2021/08/29/threats-to-validity/"/>
    <url>/2021/08/29/threats-to-validity/</url>
    
    <content type="html"><![CDATA[<p>软件工程领域里的很多论文在最后都会有Threats to Validity，之前读论文的时候都是一眼带过。自己曾经写过，也是随便写写。前几天写论文写到这一章，仔细去看了一些论文，发现这也分很多种类。搜了一下，发现还有一篇论文是专门对这个的研究。所以在这里就依据这篇论文做一个总结吧。由于现在我的研究方向是机器学习，所以就结合这个方向进行讨论。这些都是我所理解的，可能不严谨，也可能不正确。</p><p>作者首先强调了一些概念，有效性(validity)关心的是得出的结论怎样可能会错，也就是说，结论和现实之间的关系。它和质量(quality)不同，质量比有效性大很多，例如可复现性(replicability)就属于一个研究的质量，而不是有效性。另外，有效性是一个目标。一个有效性威胁(validity threat, VT)就是一个在前往目标时，你可能会出错的路径。</p><p>作者将Threats to Validity分成了以下几类：</p><h2 id="Conclusion-Validity"><a href="#Conclusion-Validity" class="headerlink" title="Conclusion Validity"></a>Conclusion Validity</h2><p>大多数人都认为结论有效性是特指“统计”学上的有效性，其实并不是，几乎所有工作都会有结论有效性（只要你得出结论了）。结论有效性是指我们从数据的关系中得出的结论的合理程度。只要你的论文是在说明某种关系，那么结论无非就是两种结果，有关系或没有关系。无论是哪种情况，得出的结论都有可能是错的。有可能本来没有关系，你的结论是有关系，也有可能本来有关系，只是你没有发现而已。结论有效性就是在讨论这种可能性。</p><p>举个例子，如果你通过统计一些数据发现学校中参加某一个项目的学生成绩都很高，其他学生的成绩都很低。结论有效性就是根据这些数据就得出这样结论的合理性。也许参加这个项目并不是原因而是结果（可能参加项目的门槛就是成绩优秀），也许这些学生本来就比对照组聪明，这就导致了结论的不合理性。</p><p>在机器学习中，大部分时间就是在提出一个新的方法，通过实验来证明这种方法可以达到更好的效果。这本质上也是在证明你提出的方法和更好的结果之间存在必然的关系。所以，这时结论有效性就应该讨论你所提出的方法是否是导致更好效果的原因。也就是说，到底是你提出的方法导致结果变好，还是有可能是由于其它的原因导致结果变好。</p><p>不过在机器学习中，这个类别不是经常被讨论，因为你可以通过消融实验(ablation study)来证明你提出的方法的有效性。</p><h2 id="Internal-Validity"><a href="#Internal-Validity" class="headerlink" title="Internal Validity"></a>Internal Validity</h2><p>内部有效性就是说采用方法的内部的有效性，所以，讨论内部有效性的前提是，已经有证据证明所采用的方法对最终的结果有影响。有人说结论有效性是内部有效性的特例，但是当它们两个分开的时候，内部有效性更多地关注于方法内部。下图就形象地表达了内部有效性。<br><img src="/images/threats/internal_validity.gif"></p><p>机器学习中的内部有效性最常见的是超参数的设置了，超参数的不同可能会导致结果的偏差。这也很好理解，你提出了新的方法，或者改进，你实现的方法和别人实现的方法肯定不完全相同。就算你是在某个方法上进行的更改，那么你也不能保证其它对比的方法都是在一个代码上进行的更改。所以，你用了你的方法，同时也引入了其它的不可预期的变量。有时候看似你的方法，模型效果很好，但可能是超参数的原因。除非你有大规模的调参，或者在所有的实验上，包括对比方法的参数、技巧（例如warmup等提分的技巧）都设置成一模一样（通常来说不太可能实现），那么内部有效性都会超参数这一项。</p><h2 id="Construct-Validity"><a href="#Construct-Validity" class="headerlink" title="Construct Validity"></a>Construct Validity</h2><p>在论文中，我们都会基于一个理论，提出一种方法，然后通过对这个方法观测到的结果，来进行推论，从基于的这个理论，推理到结果所基于的理论。因此就会存在两种结界：第一种是观测到的结界，从提出的方法到观测到的实验结果；另一种是理论的结界，从提出方法基于的理论到结果的理论。通过下图可以很直观地看到。<br><img src="/images/threats/construct_validity.gif"></p><p>我们所能保证的是下面的，观测到的是真实的，但是无法保证你所说明的，基于观测到的理论的完全正确性，包括两个结界之间的联系，以及理论中Cause Construct到Effect Construct的推论是否正确。所以，结构有效性关注的就是你所基于的，解释的理论是否是正确的。</p><p>例如，你为了证明一个新的学习桌对小学生的成绩有提升的作用，你为它们换上了学习桌。这么看来你所做的改变仅仅是书桌，而最终的结果也证明了你的猜想。但是有可能是你错了，学生成绩提高的原因是它得到了更多的关注。所以，你虽然改变的仅仅是书桌，但是改变书桌所带来的其它不可预期的变化，可能导致你得出错误的结论。</p><p>机器学习中，举一个例子就是我如果用自监督学习来提高某一个任务的性能。最后实验也证明了使用自监督学习可以提升结果。但是自监督使用的数据集里面包括了下游任务的测试集中的数据，那么这就叫结构有效性。</p><p>有人可能会混淆内部有效性和结构有效性，我的理解是，内部有效性关注的是是你在实践中引入的其它因子，而结构有效性指的是在依据理论进行实践时，这个从理论到实践的环节，是否是一一对应的。拿很火的Transformer举例，作者认为RNN不能并行计算，速度很慢，而且对长序列依赖来说效果不好，因此提出了Transformer模型，最终发现Transformer的结果要比RNN更好，速度更快。所以这里的内部有效性就是实验中使用的Transformer是否和对比的RNN一样的超参数设置，并且模型大小是否相当，其它的各种变量都相同。而结构有效性就是Transformer是否是像作者解释的那样，速度快是因为使用了多头注意力机制，从而可以并行，而不是另外的原因。</p><h2 id="External-Validity"><a href="#External-Validity" class="headerlink" title="External Validity"></a>External Validity</h2><p>简单来说外部有效性就是泛化性。关注的是样本是否代表所有情况，在其它情况下的是否还会得到相同的结果。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] Feldt, Robert, and Ana Magazinius. “Validity Threats in Empirical Software Engineering Research-An Initial Survey.”</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
